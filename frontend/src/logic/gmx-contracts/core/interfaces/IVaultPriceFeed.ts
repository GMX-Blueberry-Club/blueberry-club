/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface IVaultPriceFeedInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "adjustmentBasisPoints"
      | "getAmmPrice"
      | "getLatestPrimaryPrice"
      | "getPrice"
      | "getPrimaryPrice"
      | "isAdjustmentAdditive"
      | "setAdjustment"
      | "setFavorPrimaryPrice"
      | "setIsAmmEnabled"
      | "setIsSecondaryPriceEnabled"
      | "setMaxStrictPriceDeviation"
      | "setPriceSampleSpace"
      | "setSpreadBasisPoints"
      | "setSpreadThresholdBasisPoints"
      | "setTokenConfig"
      | "setUseV2Pricing"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "adjustmentBasisPoints",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getAmmPrice",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getLatestPrimaryPrice",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getPrice",
    values: [AddressLike, boolean, boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getPrimaryPrice",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "isAdjustmentAdditive",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setAdjustment",
    values: [AddressLike, boolean, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setFavorPrimaryPrice",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsAmmEnabled",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsSecondaryPriceEnabled",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxStrictPriceDeviation",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceSampleSpace",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setSpreadBasisPoints",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setSpreadThresholdBasisPoints",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenConfig",
    values: [AddressLike, AddressLike, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setUseV2Pricing",
    values: [boolean]
  ): string;

  decodeFunctionResult(
    functionFragment: "adjustmentBasisPoints",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAmmPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLatestPrimaryPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getPrice", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getPrimaryPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAdjustmentAdditive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAdjustment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFavorPrimaryPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsAmmEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsSecondaryPriceEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxStrictPriceDeviation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceSampleSpace",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSpreadBasisPoints",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSpreadThresholdBasisPoints",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setUseV2Pricing",
    data: BytesLike
  ): Result;
}

export interface IVaultPriceFeed extends BaseContract {
  connect(runner?: ContractRunner | null): BaseContract;
  attach(addressOrName: AddressLike): this;
  deployed(): Promise<this>;

  interface: IVaultPriceFeedInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  adjustmentBasisPoints: TypedContractMethod<
    [_token: AddressLike],
    [bigint],
    "view"
  >;

  getAmmPrice: TypedContractMethod<[_token: AddressLike], [bigint], "view">;

  getLatestPrimaryPrice: TypedContractMethod<
    [_token: AddressLike],
    [bigint],
    "view"
  >;

  getPrice: TypedContractMethod<
    [
      _token: AddressLike,
      _maximise: boolean,
      _includeAmmPrice: boolean,
      _useSwapPricing: boolean
    ],
    [bigint],
    "view"
  >;

  getPrimaryPrice: TypedContractMethod<
    [_token: AddressLike, _maximise: boolean],
    [bigint],
    "view"
  >;

  isAdjustmentAdditive: TypedContractMethod<
    [_token: AddressLike],
    [boolean],
    "view"
  >;

  setAdjustment: TypedContractMethod<
    [_token: AddressLike, _isAdditive: boolean, _adjustmentBps: BigNumberish],
    [void],
    "nonpayable"
  >;

  setFavorPrimaryPrice: TypedContractMethod<
    [_favorPrimaryPrice: boolean],
    [void],
    "nonpayable"
  >;

  setIsAmmEnabled: TypedContractMethod<
    [_isEnabled: boolean],
    [void],
    "nonpayable"
  >;

  setIsSecondaryPriceEnabled: TypedContractMethod<
    [_isEnabled: boolean],
    [void],
    "nonpayable"
  >;

  setMaxStrictPriceDeviation: TypedContractMethod<
    [_maxStrictPriceDeviation: BigNumberish],
    [void],
    "nonpayable"
  >;

  setPriceSampleSpace: TypedContractMethod<
    [_priceSampleSpace: BigNumberish],
    [void],
    "nonpayable"
  >;

  setSpreadBasisPoints: TypedContractMethod<
    [_token: AddressLike, _spreadBasisPoints: BigNumberish],
    [void],
    "nonpayable"
  >;

  setSpreadThresholdBasisPoints: TypedContractMethod<
    [_spreadThresholdBasisPoints: BigNumberish],
    [void],
    "nonpayable"
  >;

  setTokenConfig: TypedContractMethod<
    [
      _token: AddressLike,
      _priceFeed: AddressLike,
      _priceDecimals: BigNumberish,
      _isStrictStable: boolean
    ],
    [void],
    "nonpayable"
  >;

  setUseV2Pricing: TypedContractMethod<
    [_useV2Pricing: boolean],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "adjustmentBasisPoints"
  ): TypedContractMethod<[_token: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getAmmPrice"
  ): TypedContractMethod<[_token: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getLatestPrimaryPrice"
  ): TypedContractMethod<[_token: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getPrice"
  ): TypedContractMethod<
    [
      _token: AddressLike,
      _maximise: boolean,
      _includeAmmPrice: boolean,
      _useSwapPricing: boolean
    ],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPrimaryPrice"
  ): TypedContractMethod<
    [_token: AddressLike, _maximise: boolean],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "isAdjustmentAdditive"
  ): TypedContractMethod<[_token: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "setAdjustment"
  ): TypedContractMethod<
    [_token: AddressLike, _isAdditive: boolean, _adjustmentBps: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setFavorPrimaryPrice"
  ): TypedContractMethod<[_favorPrimaryPrice: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setIsAmmEnabled"
  ): TypedContractMethod<[_isEnabled: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setIsSecondaryPriceEnabled"
  ): TypedContractMethod<[_isEnabled: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setMaxStrictPriceDeviation"
  ): TypedContractMethod<
    [_maxStrictPriceDeviation: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setPriceSampleSpace"
  ): TypedContractMethod<
    [_priceSampleSpace: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setSpreadBasisPoints"
  ): TypedContractMethod<
    [_token: AddressLike, _spreadBasisPoints: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setSpreadThresholdBasisPoints"
  ): TypedContractMethod<
    [_spreadThresholdBasisPoints: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setTokenConfig"
  ): TypedContractMethod<
    [
      _token: AddressLike,
      _priceFeed: AddressLike,
      _priceDecimals: BigNumberish,
      _isStrictStable: boolean
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setUseV2Pricing"
  ): TypedContractMethod<[_useV2Pricing: boolean], [void], "nonpayable">;

  filters: {};
}
